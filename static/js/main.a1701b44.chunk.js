(this.webpackJsonpdev=this.webpackJsonpdev||[]).push([[0],{20:function(e,n,t){},24:function(e,n,t){e.exports=t(44)},29:function(e,n,t){},35:function(e,n,t){},36:function(e,n,t){},37:function(e,n,t){},38:function(e,n,t){},39:function(e,n,t){},40:function(e,n,t){},41:function(e,n,t){},42:function(e,n,t){},43:function(e,n,t){},44:function(e,n,t){"use strict";t.r(n);var a=t(0),r=t.n(a),l=t(10),o=t.n(l),i=(t(29),t(9)),c=t(1);function s(){return r.a.createElement(r.a.Fragment,null,r.a.createElement("h1",null,"We haven't implemented this yet :-("),r.a.createElement("p",null,"Can you help us implement it ",r.a.createElement("a",{href:"https://github.com/datastructures-dev/datastructures-dev.github.io/"},"here")))}function d(e){return r.a.createElement("ul",null,e.pages.map((function(n){var t="".concat(e.prefix,"/").concat(n.route);return r.a.createElement("li",{key:t},r.a.createElement(i.b,{to:t},n.name))})))}function u(e){return r.a.createElement(c.d,null,r.a.createElement(c.b,{exact:!0,path:e.prefix},e.rootPage),e.pages.map((function(n){var t="".concat(e.prefix,"/").concat(n.route);return r.a.createElement(c.b,{key:t,exact:!0,path:t},n.page)})),e.children)}t(35);function h(e){return r.a.createElement("div",{className:"card-grid ".concat(e.className)},e.children)}function m(e){return r.a.createElement("div",{className:"card ".concat(e.className)},e.children)}var g=t(2);t(36);function p(e){return r.a.createElement("section",{className:"Controls"},e.children)}function f(e){return r.a.createElement("div",{className:"ControlGroup"},e.children)}function x(e){return r.a.createElement("section",{className:"Visual"},e.children)}function v(e){return r.a.createElement("section",{className:"Complexity"},r.a.createElement("table",null,r.a.createElement("thead",null,r.a.createElement("tr",null,r.a.createElement("th",{colSpan:"2"},"Complexity"))),r.a.createElement("tbody",null,e.complexity.map((function(e){return r.a.createElement("tr",{key:e.name},r.a.createElement("td",null,e.name),r.a.createElement("td",null,e.complexity))})))))}function E(e){return r.a.createElement("section",{className:"About"},e.children)}function y(e){return r.a.createElement("article",{className:"VisualPage"},r.a.createElement("h1",null,e.title),e.children)}t(37);function b(e){return r.a.createElement("div",{className:"linked-list"},e.children)}function w(e){return r.a.createElement("div",{className:"linked-list-node"+(e.highlight?" highlight":"")},e.children)}function k(){var e=Object(a.useState)([]),n=Object(g.a)(e,2),t=n[0],l=n[1],o=Object(a.useState)(-1),i=Object(g.a)(o,2),c=i[0],s=i[1],d=Object(a.useState)(-1),u=Object(g.a)(d,2),h=u[0],m=u[1],v=Object(a.useState)(),E=Object(g.a)(v,2),y=E[0],k=E[1],C=Object(a.useState)(),j=Object(g.a)(C,2),O=j[0],A=j[1],I=Object(a.useState)(),S=Object(g.a)(I,2),D=S[0],R=S[1];function N(e){for(var n=t.map((function(e){return Object.assign({},e,{highlight:!1})})),a=!1,r={next:e?-1:c,value:y,highlight:!1},o=0;o<n.length&&!a;o++)void 0===n[o]&&(n[o]=r,a=!0);a||(o=n.length,n.push(r)),e?(-1===h||(n[h].next=o),m(o),-1===c&&s(o)):(s(o),-1===h&&m(o)),l(n)}var F=null,_=!1;for(var B=[],L=c;-1!==L;)B.push(r.a.createElement(w,{key:L,highlight:t[L].highlight},t[L].value)),L=t[L].next;return r.a.createElement(r.a.Fragment,null,r.a.createElement(p,null,r.a.createElement(f,null,r.a.createElement("label",{htmlFor:"add"},"Add item"),r.a.createElement("input",{name:"add",type:"text",onChange:function(e){return k(e.target.value)}}),r.a.createElement("button",{onClick:function(){return N(!1)}},"Add Front"),r.a.createElement("button",{onClick:function(){return N(!0)}},"Add End")),r.a.createElement(f,null,r.a.createElement("label",{htmlFor:"search"},"Search"),r.a.createElement("input",{name:"search",onChange:function(e){return A(e.target.value)}}),r.a.createElement("button",{onClick:function(){l(t.map((function(e,n){return Object.assign({},e,{highlight:!1})})));var e=c,n=[],a=setInterval((function(){if(-1===e)return l(t.map((function(e,t){return Object.assign({},e,{highlight:n.includes(t)&&e.value===O})}))),void clearInterval(a);l(t.map((function(t,a){return Object.assign({},t,{highlight:a===e||t.value===O&&n.includes(a)})}))),n.push(e),e=-1!==e&&t[e].value===O?-1:t[e].next}),1e3)}},"Search")),r.a.createElement(f,null,r.a.createElement("label",{htmlFor:"remove"},"Remove"),r.a.createElement("input",{name:"remove",onChange:function(e){return R(e.target.value)}}),r.a.createElement("button",{onClick:function(){!function(e){l(t.map((function(e,n){return Object.assign({},e,{highlight:!1})})));var n=c,a=[],r=setInterval((function(){if(-1===n)return l(t.map((function(n,t){return Object.assign({},n,{highlight:a.includes(t)&&n.value===e})}))),void clearInterval(r);l(t.map((function(t,r){return Object.assign({},t,{highlight:r===n||t.value===e&&a.includes(r)})}))),a.push(n),-1!==n&&t[n].value===e?(_=!0,F=n,n=-1,console.log("Found")):n=t[n].next}),500)}(D),setTimeout((function(){if(!1===_)alert("Value: "+D+" is not in the list");else{for(var e=Object.assign([],t),n=null,a=c;a!==F;)n=a,a=t[a].next,console.log("Here "+n+" "+a);if(console.log("tHere "+n+" "+a),null===n&&-1===e[a].next)s(-1),l([]);else if(null!==n){var r=e[a].next;e[n].next=r,console.log(e),l(e)}else{var o=e[a].next;s(o),e.splice(a,1),console.log(e),l(e)}}}),2e3)}},"Remove"))),r.a.createElement(x,null,r.a.createElement(b,null,B)))}var C=t(11),j=t(45);t(38);function O(e){return r.a.createElement("div",{className:"stack"},e.children)}function A(e){return r.a.createElement(j.a,{appear:!0,in:e.show,onExited:e.onExited,timeout:200,unmountOnExit:!0,classNames:"stack-node"},r.a.createElement("div",{className:"stack-node"+(e.highlight?" highlight":"")},e.children))}function I(){var e=Object(a.useState)([]),n=Object(g.a)(e,2),t=n[0],l=n[1],o=Object(a.useState)(),i=Object(g.a)(o,2),c=i[0],s=i[1];function d(){l(t.slice(0,t.length-1))}return r.a.createElement(r.a.Fragment,null,r.a.createElement(p,null,r.a.createElement(f,null,r.a.createElement("label",{htmlFor:"add"},"Add item"),r.a.createElement("input",{name:"add",type:"text",onChange:function(e){return s(e.target.value)}}),r.a.createElement("button",{onClick:function(){l([].concat(Object(C.a)(t),[{value:c,highlight:!1,show:!0}]))}},"Push")),r.a.createElement(f,null,r.a.createElement("button",{onClick:function(){l([].concat(Object(C.a)(t.slice(0,t.length-1)),[Object.assign({},t[t.length-1],{show:!1})]))}},"Pop"))),r.a.createElement(x,null,r.a.createElement(O,null,t.map((function(e,n){return r.a.createElement(A,{key:n,index:n,show:e.show,highlight:e.highlight,onExited:d},e.value)})))))}t(20);function S(e){return r.a.createElement("div",{className:"queue"},e.children)}function D(e){return r.a.createElement(j.a,{appear:!0,in:e.show,onExited:e.onExited,timeout:200,unmountOnExit:!0,classNames:"queue-node"},r.a.createElement("div",{className:"queue-node"+(e.highlight?" highlight":"")},e.children))}function R(){var e=Object(a.useState)([]),n=Object(g.a)(e,2),t=n[0],l=n[1],o=Object(a.useState)(),i=Object(g.a)(o,2),c=i[0],s=i[1];function d(){l(t.slice(1))}return r.a.createElement(r.a.Fragment,null,r.a.createElement(p,null,r.a.createElement(f,null,r.a.createElement("label",{htmlFor:"add"},"Add item"),r.a.createElement("input",{name:"add",type:"text",onChange:function(e){return s(e.target.value)}}),r.a.createElement("button",{onClick:function(){l([].concat(Object(C.a)(t),[{value:c,highlight:!1,show:!0}]))}},"Enqueue")),r.a.createElement(f,null,r.a.createElement("button",{onClick:function(){l([Object.assign({},t[0],{show:!1})].concat(Object(C.a)(t.slice(1))))}},"Dequeue"))),r.a.createElement(x,null,r.a.createElement(S,null,t.map((function(e,n){return r.a.createElement(D,{key:n,index:n,show:e.show,highlight:e.highlight,onExited:d},e.value)})))))}t(39);function N(e){return r.a.createElement("div",{className:"array"},e.children)}function F(e){return r.a.createElement(j.a,{appear:!0,in:e.show,onExited:e.onExited,timeout:200,unmountOnExit:!0,classNames:"array-index"},r.a.createElement("span",{className:"array-index"+(e.highlight?" highlight":"")},e.children))}function _(){var e=Object(a.useState)([]),n=Object(g.a)(e,2),t=n[0],l=n[1],o=Object(a.useState)(-1),i=Object(g.a)(o,2),c=i[0],s=i[1],d=Object(a.useState)(0),u=Object(g.a)(d,2),h=u[0],m=u[1],v=Object(a.useState)(0),E=Object(g.a)(v,2),y=E[0],b=E[1];function w(){l(t.slice(1))}return r.a.createElement(r.a.Fragment,null,r.a.createElement(p,null,r.a.createElement(f,null,r.a.createElement("label",{htmlFor:"create"},"Array Length"),r.a.createElement("input",{name:"add",type:"text",onChange:function(e){return m(e.target.value)}}),r.a.createElement("button",{onClick:function(){for(var e=[],n=0;n<h;n++)e.push({value:" ",highlight:!1,show:!0});l(e)}},"Create Array")),r.a.createElement("label",{htmlFor:"index"},"Index"),r.a.createElement("input",{name:"index",type:"number",onChange:function(e){return b(e.target.value)}}),r.a.createElement(f,null,r.a.createElement("label",{htmlFor:"add"},"Add item"),r.a.createElement("input",{name:"add",type:"text",onChange:function(e){return s(e.target.value)}}),r.a.createElement("button",{onClick:function(){var e=Object.assign([],t);e[y]={value:c,highlight:!1,show:!0},l(e)}},"Insert at Index")),r.a.createElement(f,null,r.a.createElement("button",{onClick:function(){var e=Object.assign([],t);e[y]={value:" ",highlight:!1,show:!0},l(e)}},"Remove from Index"))),r.a.createElement(x,null,r.a.createElement(N,null,t.map((function(e,n){return r.a.createElement(F,{key:n,index:n,show:e.show,highlight:e.highlight,onExited:w},e.value)})))))}var B=t(22);t(40),t(41);function L(e){return r.a.createElement("div",{className:"heap"},e.children)}var T="<html>\n\n<head>\n  <link  href=\"./styles/styles.css\" />\n  <link  href=\"./styles/style.css\" />\n  <script src=\"https://d3js.org/d3.v4.min.js\"><\/script>\n\n</head>\n\n<body>\n  \n  \n\n    \n      \n      <input type=\"number\" id=\"len\" placeholder=\"Insert length of randomized array\"></input>\n        <button id=\"click\" onclick=\"clickity()\">Generate Arr of Length</button>\n        <button id=\"Refresh\" onclick=\"refresh()\">Refresh</button>\n\n  <div id=\"heap\">\n  </div>\n \n  \n</body>\n<script src=\"https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js\" type=\"text/javascript\"><\/script>\n<script type=\"text/javascript\" src=\"./heapsort/static/heap.js\"><\/script>\n\n<script type=\"text/javascript\">\nfunction run(){\n  var arr = []\n  console.log(\"Here\")\n  makeRandArray()\n  console.log(arr)\n  var duration = 500; // 700 a good moderate speed\n  var colorduration = 100;\n  var textTransDuration = 700;\n  var swapDelay = 1000;\n  var textRemoveDuration = 3000;\n  var compareDuration = 3000;\n  var addColorDuration = 1000;\n\n  var margin = { top: 50, right: 90, bottom: 30, left: 90 },\n    width = 960 - margin.left - margin.right,\n    height = 500 - margin.top - margin.bottom;\n\n  var svg = d3.select(\"body\")\n    .append(\"svg\")\n    .attr(\"width\", width + margin.right + margin.left)\n    .attr(\"height\", height + margin.top + margin.bottom)\n\n  var textSpacing = 40;\n  var arrtext = svg.append(\"g\").attr(\"class\", 'arrtext')\n\n  arrtext\n    .append('text').text('[')\n    .attr('transform', 'translate(10,20)');\n\n  var arrtextg = arrtext.selectAll('.eletext').data(arr).enter().append('g')\n    .attr('id', function (d, i) {\n      return (\"artextg\" + i);\n    })\n    .attr('transform', function (d, i) {\n      var xtran = i * textSpacing + 20;\n      var ytran = 20;\n      return \"translate(\" + xtran + ', ' + ytran + ')';\n    })\n    .attr('x', function (d, i) {\n      var xtran = i * textSpacing + 20;\n      return xtran\n    })\n\n  arrtextg.append('rect', ':first-child')\n    .attr('width', function (d, i) {\n      //          console.log('this = ', this, 'd = ', d)\n      return 20\n    })\n    .attr('height', 20)\n    .attr('transform', 'translate(0, -15)')\n    .attr('fill', 'none')\n    .attr('opacity', .4)\n  //        .transition(duration * 100)\n  //      .attr('fill', 'white')\n\n  arrtextg.append('text')\n    .text(function (d, i) {\n      //    console.log(d, i, arr.length);\n      return (i === arr.length - 1) ? d : (d + ', ');\n    })\n    .attr('class', 'eletext')\n    .attr('id', function (d, i) {\n      return 'arrText' + i;\n    })\n    .attr('stroke', 'grey')\n    .attr('fill', 'black')\n\n\n  arrtext.append('text').text(']')\n    .attr('transform', 'translate(' + ((arr.length + 1) * textSpacing) + ',20)');\n\n  arrtextg.attr('textbox', function (d) {\n    //  console.log('this arrtext = ', d3.select(this).select('text').node().getBBox().width)\n    var textW = d3.select(this).select('text').node().getBBox().width\n    d3.select(this).select('rect').attr('width', textW)\n    return d3.select(this).select('text').node().getBBox().width;\n  })\n\n\n  var g = svg.append(\"g\")\n    .attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\");\n\n\n  // declares a tree layout and assigns the size\n  var treemap = d3.tree()\n    .size([width, height]);\n\n  var newsource = { name: arr[0], children: getChildren(0, arr) }\n\n  console.log(newsource);\n\n  var root = d3.hierarchy(newsource, function (d) { return d.children; });\n\n  root.x0 = 5;\n  root.y0 = 0;\n\n  // Make the root and all it's children null and move into _children attribute\n  collapse(root)\n  update(root);\n  runprom(root);\n\n  function runprom(dat) {\n    promun(dat)\n      .then(function (d) {\n        var nodescendants = true;\n        //  console.log('finished the promise', d.descendants())\n        for (i of root.descendants()) {\n          //  console.log(i)\n          if (i._children) {\n            nodescendants = false;\n            runprom(i)\n            break;\n          }\n        }\n        if (nodescendants === true) {\n          //      console.log('done buidling heap, now to max heap')\n          buildMaxHeap();\n        }\n      });\n  }\n\n\n  function promun(ino) {\n    var innodes = ino.descendants();\n    return new Promise(function (res, rej) {\n      //console.log('inpromise', ino)\n      unfold(ino);\n      d3.timeout(function () {\n        res(ino)\n      }, 2000);\n\n    })\n  }\n\n  function unfold(data) {\n    //console.log('unfolding, ', data)\n    //\tupdate(data)\n    if (data._children) {\n      if (data._children.length > 0) {\n        if (data.children === null) { data.children = [] }\n        data.children.push(data._children.shift())\n        if (data._children.length === 0) {\n          data._children = null;\n        }\n      }\n\n      setTimeout(function (d) {\n        update(data)\n        //console.log('should try to unfold data')\n        unfold(data)\n      }, 400)\n    }\n  }\n\n\n  function getChildren(i, array) {\n    var childs = [];\n    var nextIndex = i * 2 + 1;\n    if (typeof (array[i * 2 + 1]) === \"number\") {\n      childs[0] = { name: array[i * 2 + 1], children: [] };\n      if (typeof (array[i * 2 + 2]) === \"number\") {\n        childs[1] = { name: array[i * 2 + 2] };\n      }\n    }\n\n    if (typeof (arr[nextIndex * 2 + 1]) === \"number\") {\n      childs[0].children = getChildren(nextIndex, array)\n      childs[0]._children = null;\n\n      if (typeof (arr[nextIndex * 2 + 2]) === \"number\") {\n        childs[1].children = getChildren(nextIndex + 1, array);\n        childs[1]._children = null;\n      }\n    }\n\n    return childs\n  }\n\n  var nodes;\n  function update(data) {\n    //console.log(data)\n    //  var mapData = data.map()\n\n    var treeData = treemap(root);\n    nodes = treeData.descendants();\n\n    var links = treeData.descendants().slice(1);\n    // console.log(nodes);\n    //  console.log(\"nodes = \", nodes, \", links = \", links);\n\n    var node = g.selectAll('g.node')\n      .data(nodes, function (d, i) {\n        return d.id = i;\n      })\n\n    //\tconsole.log('node = ', node)\n\n    var nodeEnter = node.enter().append('g')\n      .attr('class', 'node')\n      .attr('transform', function (d) {\n        //\t\t  console.log('appending a new node', d);\n        d3.select('#artextg' + d.id)\n          .call(function (d) {\n            //  console.log('this is', this, d)\n            d.select('rect')\n              .attr('fill', 'red')\n              .transition()\n              .duration(duration * 2)\n              .attr('fill', 'white')\n          })\n\n        return 'translate( ' + data.x0 + ', ' + data.y0 + ' )';\n      })\n      .attr('id', function (d, i) {\n        return 'nodey' + i;\n      })\n      .attr('index', function (d, i) {\n        return i;\n      })\n\n\n    nodeEnter.append('circle')\n      .attr('class', 'node')\n      .attr('r', 1e-6)\n      .style('fill', function (d) {\n        return \"red\" //d._children ? \"lightsteelblue\" : \"#fff\";\n      })\n\n    // Labels for the nodes\n    nodeEnter.append('text')\n      .attr(\"dy\", \".35em\")\n      .attr(\"y\", function (d, i) {\n        return -15\n      })\n      .attr(\"x\", function (d, i) {\n        var xmove = i % 2;\n        return xmove ? -16 : 3 //d.children || d._children ? 1 : 1;\n      })\n      .attr(\"text-anchor\", function (d, i) {\n        var xmove = i % 2;\n        return xmove ? \"end\" : \"start\"; //d.children || d._children ? \"end\" : \"start\";\n      })\n      .attr(\"class\", \"valtext\")\n      .text(function (d) {\n        return d.data.name;\n      });\n\n    // UPDATE\n    var nodeUpdate = nodeEnter.merge(node)\n      .transition()\n      .duration(duration)\n      // .text(function(d) { return d.data.name; })\n      .attr('transform', function (d) {\n        return \"translate(\" + d.x + \",\" + d.y + \")\"\n      })\n      .on('end', function (d) {\n\n        /*\n                 nodeUpdate.select('circle.node')\n                 .transition()\n                 .duration(addColorDuration)\n                 .style(\"fill\", function(d) {\n                             return \"steelblue\"//d._children ? \"lightsteelblue\" : \"#fff\";\n                         })\n                         */\n      })\n\n    // Update the node attributes and style\n    nodeUpdate.select('circle.node')\n      .attr('r', 10)\n      .attr('cursor', 'pointer')\n      .style('stroke', 'black')\n      .style('stroke-width', '2px')\n      .transition()\n      .duration(addColorDuration)\n      .style(\"fill\", function (d) {\n        return \"steelblue\"//d._children ? \"lightsteelblue\" : \"#fff\";\n      })\n\n\n    // Remove any exiting nodes\n    var nodeExit = node.exit().transition()\n      .duration(duration)\n      .attr(\"transform\", function (d) {\n        return \"translate(\" + data.x + \",\" + data.y + \")\";\n      })\n      .remove();\n\n    // On exit reduce the node circles size to 0\n    nodeExit.select('circle')\n      .attr('r', 1e-6);\n\n    // On exit reduce the opacity of text labels\n    nodeExit.select('text')\n      .style('fill-opacity', 1e-6);\n\n    // ****************** links section ***************************\n\n    // Update the links...\n    var link = g.selectAll('path.link')\n      .data(links, function (d) { return d.id; });\n\n    // Enter any new links at the parent's previous position.\n    var linkEnter = link.enter().insert('path', \"g\")\n      //   .on('click', click)\n      .attr(\"class\", \"link\")\n      .attr('d', function (d) {\n        var o = { y: data.y0, x: data.x0 }\n        return diagonal(o, o)\n      })\n      .style('fill', 'none')\n      .style('stroke', 'black');\n\n    // UPDATE\n    var linkUpdate = linkEnter.merge(link);\n\n    // Transition back to the parent element position\n    linkUpdate.transition()\n      .duration(duration)\n      .attr('d', function (d) { return diagonal(d, d.parent) });\n\n\n    // Remove any exiting links\n    var linkExit = link.exit().transition()\n      .duration(duration)\n      .attr('d', function (d) {\n        var o = { x: data.x, y: data.y }\n        return diagonal(o, o)\n      })\n      .remove();\n\n    // Store the old positions for transition.\n    nodes.forEach(function (d, i) {\n      //   console.log(d)\n      d.x0 = d.x;\n      d.y0 = d.y;\n    });\n\n  }\n\n  // Make the node and all it's children null and move into _children attribute\n  function collapse(d) {\n    if (d.children) {\n      d._children = d.children;\n      d._children.forEach(collapse);\n      d.children = null;\n    }\n  }\n\n"+function(e,n){return"M ".concat(e.x," ").concat(e.y,"\n  C ").concat((e.x+n.x)/2," ").concat(e.y,",\n    ").concat((e.x+n.x)/2," ").concat(n.y,",\n    ").concat(n.x," ").concat(n.y)}+"\n  // Creates a curved (diagonal) path from parent to the child nodes\n  // switched around all the x's and y's from orig so it's verticle\n  function diagonal(s, d) {\n    //console.log('in diag and s = ', s);\n    //console.log('d = ', d)\n\n    path = getPath(s,d)\n\n    return path;\n\n  }\n\n\n  function colorAllCircsGreen() {\n    d3.selectAll('circle')\n      .transition()\n      .duration(colorduration)\n      .style('fill', 'green')\n  }\n\n  var noders;\n\n\n  function buildMaxHeap() {\n\n    noders = d3.selectAll('g.node');\n    console.log('time to makeheapify', noders)\n    var numnodes = noders._groups[0].length;\n\n    var holders = { restartIndex: Math.floor((numnodes) / 2) - 1, bigChild: null }\n    console.log('holders to start = ', holders)\n    max_heapify(Math.floor((numnodes) / 2) - 1, holders)\n\n  }\n\n\n  function bigChildIndex(ind) {\n    //  console.log(ind);\n\n    var chillies = [];\n    if (nodes[ind]) {\n      chillies = nodes[ind].children;\n      if (chillies[1]) {\n        return (parseInt(chillies[0].data.name) > parseInt(chillies[1].data.name)) ? 0 : 1;\n      }\n      else {\n        return 0;\n      }\n    }\n    else {\n      return -1;\n    }\n    //  console.log(chillies)\n  }\n\n  function max_heapify(ind, holders) {\n    //    console.log('max heap from isnt going ', nodes[ind])\n    if (holders === null) {\n      holders = {}\n    }\n    noders = d3.selectAll('g.node')\n    var childindexes = []\n    holders.bigChild = bigChildIndex(ind)\n    holders.starter = ind;\n\n    if (nodes[ind].children) {\n      childindexes = nodes[ind].children.map(function (d, i) {\n        return d.id;\n      })\n    }\n\n    //  console.log('childindexes are', childindexes)\n    var anode = d3.select('#nodey' + ind)\n\n    changeRectColor(ind, 'red');\n\n    anode.select('circle')\n      .transition()\n      .duration(duration + textTransDuration)\n      .style('fill', 'red')\n      .on('end', function (d) {\n        //      console.log('holders', holders)\n        compareChils(childindexes, holders)\n      })\n\n\n\n    var comptext = 'compare the childrens';\n    anode.append('text')\n      .text(comptext)\n      .attr(\"text-anchor\", function (d) {\n        return 'middle';\n      })\n      .attr(\"dy\", '20px')\n      .attr('class', 'process')\n  }\n\n  function compareChils(childsArr, holders) {\n    colorForComp(childsArr[0], holders);\n    if (childsArr[1]) {\n      colorForComp(childsArr[1], holders);\n    }\n  }\n\n  function colorForComp(inex, holders) {\n\n    changeRectColor(inex, 'orange')\n\n    d3.select('#nodey' + inex)\n      .select('circle')\n      .transition()\n      .duration(duration + textRemoveDuration)\n      .style('fill', function (d) {\n        return 'orange'\n      })\n      .on('end', function (d) {\n        //        console.log('done and have ', d)\n        //      console.log(holders)\n        //     console.log(nodes[holders.restartIndex].children[holders.bigChild])\n        if (nodes[holders.starter].children[holders.bigChild] === d) {\n          //         console.log('its the big child need to check swaping')\n\n          changeRectColor(inex, 'yellow')\n\n          d3.select(this).transition()\n            .duration(duration + 200)\n            .style('fill', 'yellow')\n            .on('end', function () {\n              checkParentSwap(d, holders);\n            })\n        }\n        else {\n          console.log('this should make it green')\n\n          d3.select(this)\n            .transition()\n            .duration(colorduration)\n            .style('fill', 'green')\n          changeRectColor(inex, 'green')\n        }\n      })\n  }\n\n  function checkParentSwap(d, holders) {\n    // check if the given thing is bigger than the parent node\n    // and if not decrement holders.restartIndex and call the max heap thing with that\n    //console.log(\"d = \" , d)\n    var childer = d;\n    var cnode = d3.select('#nodey' + (d.id));\n    var pnode = d3.select('#nodey' + (d.parent.id));\n\n    console.log('parent node id = ', pnode.attr('id'))\n\n    d3.select('.process').text('Compare with largest child')\n\n\n    if (d.data.name > d.parent.data.name) {\n      d3.select('.process').text('Compare with largest child')\n        .transition()\n        .duration(compareDuration)\n        .delay(swapDelay)\n        .text(\"swap with big child\")\n        .on('end', function (d) {\n          //    console.log('swap with parent ', childer, holders);\n          //  changeRectColor(pnode.attr('id').slice(pnode.attr('id').length-1), 'green');\n          swapWithParent(childer, holders)\n        })\n        .on('interrupt', function (d) {\n          //    console.log('swap with parent ', childer, holders);\n          swapWithParent(childer, holders)\n        })\n        .remove();\n\n    }\n    else {\n      console.log('making stuff greenie')\n      cnode.select('circle')\n        .transition()\n        .duration(colorduration)\n        .style(\"fill\", 'green')\n        .on('end', function () {\n          console.log('maybe i should do stuff here')\n        })\n      changeRectColor(cnode.attr('index'), 'green');\n      changeRectColor(pnode.attr('index'), 'green');\n\n      d3.select('.process').text('This node is good move on')\n        .call(function () {\n          console.log('trying to just make the rects green', pnode)\n          setTimeout(function () {\n\n            console.log('why dont the rects turn green', cnode.attr('id').slice(cnode.attr('id').length - 1))\n            //    changeRectColor(pnode.attr('id').slice(pnode.attr('id').length-1), 'green');\n            //  changeRectColor(cnode.attr('id').slice(cnode.attr('id').length-1), 'green');\n\n          }, 700)\n\n        }\n        )\n        .transition()\n        .duration(3000)\n        .delay(2000)\n        .remove();\n\n      if (holders.restartIndex > 0) {\n        //    console.log('need to color stuff here', pnode)\n        changeRectColor(pnode.attr('id'), 'green');\n\n\n        pnode.select('circle')\n          .transition()\n          .duration(3000)\n          .style(\"fill\", 'green')\n\n\n        //    console.log('we get to recur!!!')\n        holders.restartIndex = holders.restartIndex - 1;\n        max_heapify(holders.restartIndex, holders)\n      }\n      else {\n        //  colorAllCircsGreen();\n        changeRectColor(pnode.attr('id'), 'green');\n        console.log('its all over')\n        changeRectColor(pnode.attr('id'), 'green');\n        popLargest();\n      }\n    }\n  }\n\n\n  function swapWithParent(bigchild, holders) {\n\n    var newLowval = bigchild.parent.data.name;\n    bigchild.parent.data.name = bigchild.data.name;\n    bigchild.data.name = newLowval;\n\n    console.log(bigchild.id, 'and we got', bigchild.parent.id)\n    swapArrayGs(bigchild.parent.id, bigchild.id)\n\n\n    var parnode = d3.select('#nodey' + (bigchild.parent.id))\n    parnode\n      .select('circle')\n      .transition()\n      .duration(duration + 2000)\n      .style('fill', 'green')\n      .on('end', function () {\n\n        parnode.select('.process')\n          .transition()\n          .delay(1000)\n          .remove();\n\n        changeRectColor(bigchild.parent.id, 'green')\n      })\n\n    var partext = parnode.select('.valtext');\n    //  console.log(partext)\n    partext\n      .transition()\n      .duration(textTransDuration)\n      .attr('transform', function (d) {\n        //    console.log('need to translate, ', d)\n        return \"translate(\" + (d.children[holders.bigChild].x - d.x) + ', ' + (d.children[holders.bigChild].y - d.y) + ')'\n      })\n      .on('end', function (d) {\n        changeRectColor(bigchild.parent.id, 'green')\n\n        d3.select(this).attr('transform', function (d) {\n          //  console.log('trying to put it back', this, d)\n          return 'translate(0,0)'\n        })\n          .text('')\n      })\n\n\n    var chinode = d3.select('#nodey' + (bigchild.id));\n\n    var chitext = chinode.select('.valtext');\n    chitext.transition()\n      .duration(textTransDuration)\n      .attr('transform', function (d) {\n        //console.log('its this.x  =', d3.select(this).attr('x'))\n        return \"translate(\" + (d.parent.x - d.x - d3.select(this).attr('x')) + ', ' + (d.parent.y - d.y) + ')'\n      })\n      .on('end', function (d) {\n        d3.select(this).attr('transform', function (d) {\n          //      console.log('trying to put it back', this, d)\n          return 'translate(0,0)'\n        })\n          .text('')\n      })\n\n    chinode.select('circle').transition()\n      .duration(duration)\n      .style('fill', 'red')\n      .on('end', function (d) {\n        //      console.log('need to do stuff with ', d)\n\n        chinode.append('text')\n          .attr('class', 'process')\n          .text(function (d) {\n            console.log(d)\n            console.log('and the holders', holders)\n            if (d.children) {\n              console.log('need to keep ballancing')\n              if (d.children.length > 0) {\n                console.log('trying to maxheap with ', holders, d)\n                changeRectColor(bigchild.index, 'red');\n                max_heapify(parseInt(d.id), holders)\n              }\n              else {\n                console.log('in the wierd stpot moving on with the', holders)\n                console.log('make all circs white fill still')\n                chinode.select('circle').transition()\n                  .duration(100)\n                  .style('fill', 'green')\n\n                changeRectColor(bigchild.attr('index'), 'green');\n\n                holders.restartIndex = holders.restartIndex - 1;\n                max_heapify(holders.restartIndex, holders)\n              }\n            }\n            else {\n              //    console.log('move on with the', holders)\n              //      console.log('rect not turning green, chinodeid = ', chinode.attr('id'))\n              chinode.select('circle').transition()\n                .duration(10)\n                .style('fill', 'green')\n\n              changeRectColor(bigchild.id, 'green');\n\n              if (holders.restartIndex > 0) {\n                holders.restartIndex = holders.restartIndex - 1;\n                max_heapify(holders.restartIndex, holders)\n              }\n              else {\n                console.log('endgame spot, done with it all')\n                changeRectColor(chinode.attr('id'), 'green');\n\n                popLargest();\n                //    colorAllCircsGreen();\n              }\n            }\n\n            return \"Check for children\";\n\n          })\n          .attr(\"text-anchor\", function (d) {\n            return 'middle';\n          })\n          .attr(\"dy\", '-20px')\n          .transition()\n          .duration(textRemoveDuration)\n          .delay(1000)\n          .style('fill', 'green')\n          .remove();\n      })\n    parnode.select('.process').remove();\n    upDateNodeVals()\n\n  }\n\n  function upDateNodeVals() {\n\n    d3.selectAll('g.node')\n      .transition()\n      .delay(swapDelay)\n      .select('text')\n      .text(function (d) {\n        //console.log('need to change all the texts', d)\n        return d.data.name\n      })\n\n  }\n\n  // a function to add a colored rectange to go behind the text in the array.\n\n  function changeRectColor(index, color) {\n\n    d3.select('#artextg' + index).select('rect')\n      .transition().duration(duration)\n      .attr('fill', color)\n\n    //  console.log('need to remove or change color of recs at right time still')\n  }\n\n  // Will swap the elements in the array at the top of the page.\n  // Just give the indexes of the elements you wish to swap.\n  function swapArrayGs(ind1, ind2) {\n\n    var g1 = d3.select('#artextg' + ind1)\n    var gx1 = g1.attr('x')\n    var g2 = d3.select('#artextg' + ind2)\n    var gx2 = g2.attr('x')\n    var g1Start = g1.select('text').text();\n    var g2Start = g2.select('text').text()\n\n    //  console.log('startiing val ', g1Start)\n    var xdis = gx2 - gx1\n\n    g1.select('text').transition()\n      .duration(duration)\n      .attr(\"transform\", \"translate(\" + xdis + ', 0)')\n      .on('end', function (d, i) {\n        //    console.log('d = ', d, 'this = ???', this)\n        g1.select('text').attr('transform', 'translate(0, 0)').text(g2Start);\n      })\n\n    g2.select('text').transition()\n      .duration(duration)\n      .attr(\"transform\", \"translate(\" + (-xdis) + ', 0)')\n      .on('end', function (d, i) {\n        //    console.log('d = ', d, 'this = ???', this)\n        g2.select('text').attr('transform', 'translate(0, 0)').text(g1Start);\n        updateRectSizes();\n      })\n  }\n\n\n  function updateRectSizes() {\n    arrtextg.attr('textbox', function (d) {\n      //  console.log('this arrtext = ', d3.select(this).select('text').node().getBBox().width)\n      var textW = d3.select(this).select('text').node().getBBox().width\n      d3.select(this).select('rect').attr('width', textW)\n      return d3.select(this).select('text').node().getBBox().width;\n    })\n  }\n\n\n  // Should take the top element in the heap and swap it with the last one,\n  // then the heap should get reballanced\n  function popLargest() {\n    console.log('done heaping now need to start sorting, should show swapping first and last elements of the array')\n\n    //console.log('need to update nodes = ', nodes)\n    // swap first with last node\n    var topper = d3.select('#nodey' + nodes[0].id)\n\n    var highval = nodes[0].data.name\n\n    var lower = d3.select('#nodey' + nodes[nodes.length - 1].id)\n    var lowval = nodes[nodes.length - 1].data.name\n\n    //  console.log('lowval is', lowval)\n    var toptransX = nodes[0].x - nodes[nodes.length - 1].x\n    var toptransY = nodes[nodes.length - 1].y - nodes[0].y\n\n    //  console.log(toptransX, 'and y= ', toptransY)\n    topper.select('.valtext')\n      .transition()\n      .attr('transform', \"translate(\" + toptransX + \", \" + toptransY + ')')\n      .on('end', function () {\n        //nodes[0].data.name = lowval;\n        //nodes[nodes.length-1].data.name = highval;\n        //    console.log('and this is', this)\n        d3.select(this).attr('transform', 'translate(0,0)')\n\n        //  upDateNodeVals()\n      })\n\n    nodes[0].data.name = lowval;\n    nodes[nodes.length - 1].data.name = highval;\n\n    swapArrayGs(0, nodes.length - 1)\n\n    MakeRectDone(nodes.length - 1, 'blue')\n\n    lower.select('circle')\n      .transition()\n      .delay(1000)\n      .duration(colorduration)\n      .style('fill', 'blue')\n      .on('end', function (d) {\n        var lastpar = nodes[nodes.length - 1].parent;\n        lastpar._children = nodes[nodes.length - 1];\n        //    console.log(lastpar, \"last parent is\")\n        var removableindex = lastpar.children.indexOf(nodes[nodes.length - 1]);\n        lastpar.children = lastpar.children.filter(function (d) {\n          return d !== nodes[nodes.length - 1]\n        })\n        if (lastpar.children.length === 0) {\n          lastpar.children = null;\n        }\n        update(lastpar)\n        //      console.log('nodes after all that,', nodes)\n        setTimeout(function () {\n          if (nodes.length === 1) {\n            console.log('All done just need to make this rectangle blue and maybe make the root go to the array.')\n            MakeRectDone(0, 'blue')\n          }\n          else {\n            max_heapify(0, {})\n          }\n\n        }, 2000)\n\n      })\n\n    //    console.log('want to make this blue')\n\n    lower.select('.valtext')\n      .transition()\n      .attr('transform', \"translate(\" + -toptransX + \", \" + -toptransY + ')')\n      .on('end', function () {\n        //nodes[0].data.name = lowval;\n        //  console.log('and this is', this)\n        d3.select(this).attr('transform', 'translate(0,0)')\n\n        upDateNodeVals()\n      })\n\n  }\n\n\n  function MakeRectDone(i) {\n    d3.select('#artextg' + i).select('rect')\n      .transition().duration(duration)\n      .attr('fill', 'none')\n      .attr('stroke', \"steelblue\")\n\n  }\n\n  function makeRandArray() {\n    var len = document.getElementById(\"len\").value;\n    console.log(\"s: \"+len)\n    for (var idx = 0; idx < len; idx++) {\n      var ele=Math.floor(Math.random() * 100)\n      console.log(\"pushing\"+ele)\n      arr.push(ele)\n    }\n    \n  }\n}\n\n  var myLink = document.getElementById('click');\n\n  function refresh(){\n    alert(\"refresh\")\n    location.reload();\n\n  }\n  function clickity() {\n    alert(\"clicked\")\n    //executeHome()\n    //var script = document.createElement(\"script\");\n    //script.type = \"text/javascript\";\n    //script.src = \"./heapsort/static/heap.js\";\n    //document.getElementsByTagName(\"head\")[0].appendChild(script);\n    run()\n    return false;\n  }\n<\/script>\n\n</html>";function P(e){return r.a.createElement(j.a,{appear:!0,in:e.show,onExited:e.onExited,timeout:200,unmountOnExit:!0,classNames:"queue-node"})}function W(){var e=Object(a.useState)([]),n=Object(g.a)(e,2),t=n[0],l=n[1],o=Object(a.useState)(0),i=Object(g.a)(o,2);i[0],i[1];function c(){l(t.slice(1))}return r.a.createElement(r.a.Fragment,null,r.a.createElement(p,null),r.a.createElement(x,null,r.a.createElement(L,null,t.map((function(e,n){return r.a.createElement(P,{key:n,index:n,show:e.show,highlight:e.highlight,onExited:c},e.value)})))))}var M=[{name:"Array",route:"array",page:function(e){return r.a.createElement(y,{title:"Array"},r.a.createElement(E,null,r.a.createElement("h4",null,"What is an Array?"),"Arrays are sequential blocks of memory in a device that store data. They are not dynamic (size won't change). They are extremely useful if we know that input will be bounded in within a fixed size (like pictures)"),r.a.createElement(v,{complexity:[{name:"Indexing",complexity:"\u0398(1)"},{name:"Set Element at Index",complexity:"\u0398(1)"},{name:"Average wasted space",complexity:"\u0398(1)"}]}),r.a.createElement(_,null))}},{name:"Queue",route:"queue",page:function(e){return r.a.createElement(y,{title:"Queue"},r.a.createElement(E,null,r.a.createElement("h4",null,"What is a Queue?"),"Queues are a FIFO (first in- first out) structure. They are used in a lot of reactive and UI related tasks, think back button on browsers"),r.a.createElement(v,{complexity:[{name:"Indexing",complexity:"\u0398(n)"},{name:"Enqueue/Dequeue Element",complexity:"\u0398(1)"},{name:"Average wasted space",complexity:"\u0398(1)"}]}),r.a.createElement(R,null))}},{name:"Stack",route:"stack",page:function(e){return r.a.createElement(y,{title:"Stack"},r.a.createElement(E,null,r.a.createElement("h4",null,"What is a Stack?"),"Stacks are a LIFO (last in- first out) structure. They are used in a lot of reactive and UI related tasks, think back button on browsers"),r.a.createElement(v,{complexity:[{name:"Indexing",complexity:"\u0398(n)"},{name:"Push/Pop Element",complexity:"\u0398(1)"},{name:"Average wasted space",complexity:"\u0398(1)"}]}),r.a.createElement(I,null))}},{name:"Linked List",route:"linked-list",page:function(e){return r.a.createElement(y,{title:"Linked List"},r.a.createElement(E,null,r.a.createElement("h4",null,"What is a Linked List?"),"Linked List is a linear data structure and it is very common data structure which consists of group of nodes in a sequence which is divided in two parts. Each node consists of its own data and the address of the next node and forms a chain."),r.a.createElement(v,{complexity:[{name:"Indexing",complexity:"\u0398(n)"},{name:"Insert/delete at beginning",complexity:"\u0398(1)"},{name:"Insert/delete at end (when last element known)",complexity:"\u0398(1)"},{name:"Insert/delete in middle",complexity:"\u0398(n) + \u0398(1)"},{name:"Average wasted space",complexity:"\u0398(1)"}]}),r.a.createElement(k,null))}},{name:"Doubly Linked List",route:"doubly-linked-list",page:s},{name:"Hash Table",route:"hash-table",page:s},{name:"Heap",route:"heap",page:function(e){return r.a.createElement(y,{title:"Heap (sift down)"},r.a.createElement(E,null,r.a.createElement("h4",null,"What is a Heap?"),"The bane of my existance."),r.a.createElement(v,{complexity:[{name:"Sorting",complexity:"\u0398(n*log(n))"},{name:"Set Element at Index",complexity:"\u0398(1)"},{name:"Average wasted space",complexity:"\u0398(1)"}]}),r.a.createElement(W,null),",",r.a.createElement(B.a,{html:T}))}},{name:"Tree",route:"tree",page:s},{name:"3-4-5 Tree & red-black tree",route:"3-4-5-tree",page:s},{name:"Graph",route:"graph",page:s}];function q(){return r.a.createElement(h,null,r.a.createElement(m,null,r.a.createElement("h4",null,"Data Structures"),r.a.createElement(d,{prefix:"/data-structures",pages:M})))}var H=function(){return r.a.createElement(u,{prefix:"/data-structures",rootPage:q,pages:M})},U=[{name:"Linear",route:"linear",page:s},{name:"Binary",route:"binary",page:s},{name:"Breadth First",route:"breadth-first",page:s},{name:"Depth First",route:"depth-first",page:s}],z=function(){return r.a.createElement(m,null,r.a.createElement("h4",null,"Search"),r.a.createElement(d,{prefix:"/algorithms/search",pages:U}))},G=function(){return r.a.createElement(u,{prefix:"/algorithms/search",rootPage:z,pages:U})},V=[{name:"Bubble",route:"bubble",page:s},{name:"Insertion",route:"insertion",page:s},{name:"Merge",route:"merge",page:s},{name:"Quick",route:"quick",page:s},{name:"Radix",route:"radix",page:s}],Q=function(){return r.a.createElement(m,null,r.a.createElement("h4",null,"Sorting"),r.a.createElement(d,{prefix:"/algorithms/sorting",pages:V}))},J=function(){return r.a.createElement(u,{prefix:"/algorithms/sorting",rootPage:Q,pages:V})},X=[{name:"Dijkstra's",route:"dijkstra",page:s},{name:"A*",route:"a-star",page:s},{name:"Bellman Ford",route:"bellman-ford",page:s}],Y=function(){return r.a.createElement(m,null,r.a.createElement("h4",null,"Shortest Path"),r.a.createElement(d,{prefix:"/algorithms/shortest-path",pages:X}))},$=function(){return r.a.createElement(u,{prefix:"/algorithms/shortest-path",rootPage:Y,pages:X})},K=[{name:"Matchings",route:"matchings",page:s},{name:"Linear Algebra",route:"linear-algebra",page:s}];function Z(){return r.a.createElement(r.a.Fragment,null,r.a.createElement("h2",null,"Algorithms"),r.a.createElement(h,null,r.a.createElement(z,null),r.a.createElement(Q,null),r.a.createElement(Y,null),r.a.createElement(m,null,r.a.createElement("h4",null,"Other Algorithms"),r.a.createElement(d,{prefix:"/algorithms",pages:K}))))}var ee=function(){return r.a.createElement(u,{prefix:"/algorithms",rootPage:Z,pages:K},r.a.createElement(G,null),r.a.createElement(J,null),r.a.createElement($,null))},ne=(t(42),function(e){var n=Object(c.g)().pathname;return r.a.createElement("header",{className:"NavBar"},r.a.createElement("nav",null,[{path:"/",text:"Home"},{path:"/data-structures",text:"Data Structures"},{path:"/algorithms",text:"Algorithms"},{path:"/about",text:"About"}].map((function(e){return r.a.createElement(i.b,{key:e.path,to:e.path,className:Object(c.f)(n,{path:"".concat(e.path,"/*"),strict:!0,exact:!0})||Object(c.f)(n,{path:e.path,strict:!0,exact:!0})?"active":""},e.text)}))))});t(43);function te(){return r.a.createElement(r.a.Fragment,null,r.a.createElement("h1",null,"DSA Visualization"),r.a.createElement("p",null,"Visualizations of data structures and algorithms"),r.a.createElement(q,null),r.a.createElement("h3",{style:{margin:"5rem auto",textAlign:"center"}},"We're still building this site so some links haven't been implemented yet!"))}function ae(){return r.a.createElement(r.a.Fragment,null,r.a.createElement("h1",null,"About"),r.a.createElement("p",null,"A repository of reactive visualisations of common Abstract Data Structures and standard Algorithms created by ",r.a.createElement("a",{href:"https://danjones.dev"},"Daniel Jones")," and ",r.a.createElement("a",{href:"https://people.rit.edu/dl1683/"},"Devansh")))}function re(){return r.a.createElement(i.a,null,r.a.createElement(ne,null),r.a.createElement(c.d,null,r.a.createElement(c.b,{path:"/data-structures"},r.a.createElement(H,null)),r.a.createElement(c.b,{path:"/algorithms"},r.a.createElement(ee,null)),r.a.createElement(c.b,{exact:!0,path:"/"},r.a.createElement(te,null)),r.a.createElement(c.b,{exact:!0,path:"/about"},r.a.createElement(ae,null)),r.a.createElement(c.b,{exact:!0,path:"/404"},r.a.createElement("h1",null,"Error 404")),r.a.createElement(c.b,{exact:!0,path:"*"},r.a.createElement(c.a,{to:"/404"}))))}Boolean("localhost"===window.location.hostname||"[::1]"===window.location.hostname||window.location.hostname.match(/^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/));o.a.render(r.a.createElement(r.a.StrictMode,null,r.a.createElement(re,null)),document.getElementById("root")),"serviceWorker"in navigator&&navigator.serviceWorker.ready.then((function(e){e.unregister()})).catch((function(e){console.error(e.message)}))}},[[24,1,2]]]);
//# sourceMappingURL=main.a1701b44.chunk.js.map